import "./chunk-PR4QN5HX.js";

// node_modules/vue-debounce/src/debounce.js
function convertTime(time) {
  const [amt, t = "ms"] = String(time).split(/(ms|s)/i);
  const types = {
    ms: 1,
    s: 1e3
  };
  return Number(amt) * types[t];
}
function debounce(fn, wait) {
  let timeout = null;
  const timer = typeof wait === "number" ? wait : convertTime(wait);
  const debounced = function(...args) {
    const later = () => {
      timeout = null;
      fn.apply(this, args);
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, timer);
    if (!timeout) {
      fn.apply(this, args);
    }
  };
  debounced.cancel = () => {
    clearTimeout(timeout);
    timeout = null;
  };
  return debounced;
}
var debounce_default = debounce;

// node_modules/vue-debounce/src/_internals.js
function toLowerMap(list) {
  return list.map((x) => x.toLowerCase());
}
function ensureArray(value) {
  if (Array.isArray(value)) {
    return value;
  }
  if (value == null) {
    return [];
  }
  return [value];
}
function mapOutListeningEvents(attrs, listenTo) {
  const elEvents = attrs ? attrs["debounce-events"] : [];
  if (elEvents && elEvents.length > 0) {
    if (Array.isArray(elEvents)) {
      return toLowerMap(elEvents);
    }
    return toLowerMap(elEvents.split(","));
  }
  return toLowerMap(ensureArray(listenTo));
}
function isEmpty(str) {
  return str === "";
}
function isLocked(key, modifiers) {
  return key === "Enter" && (!modifiers.lock || modifiers.unlock);
}
function shouldFireOnEmpty(value, key, modifiers) {
  return isEmpty(value) && modifiers.fireonempty && (key === "Enter" || key === " ");
}

// node_modules/vue-debounce/src/directive.js
function directive_default({
  lock = false,
  listenTo = "keyup",
  defaultTime = "300ms",
  fireOnEmpty = false,
  cancelOnEmpty = false,
  trim = false
} = {}) {
  return {
    created(el, {
      value: debouncedFn,
      arg: timer = defaultTime,
      modifiers
    }, vnode) {
      const combinedRules = Object.assign({
        lock,
        trim,
        fireonempty: fireOnEmpty,
        cancelonempty: cancelOnEmpty
      }, modifiers);
      const events = mapOutListeningEvents(vnode.props, listenTo);
      const fn = debounce_default((e) => {
        debouncedFn(e.target.value, e);
      }, timer);
      function handler(event) {
        const value = combinedRules.trim ? event.target.value.trim() : event.target.value;
        if (isEmpty(value) && combinedRules.cancelonempty) {
          fn.cancel();
        } else if (isLocked(event.key, combinedRules) || shouldFireOnEmpty(value, event.key, combinedRules)) {
          fn.cancel();
          debouncedFn(event.target.value, event);
        } else {
          fn(event);
        }
      }
      events.forEach((e) => {
        el.addEventListener(e, handler);
      });
    }
  };
}

// node_modules/vue-debounce/src/index.js
var src_default = directive_default;
export {
  debounce_default as debounce,
  src_default as default,
  directive_default as vueDebounce
};
//# sourceMappingURL=vue-debounce.js.map
